const express = require('express');
const { auth, authorize } = require('../middleware/auth');
const logger = require('../utils/logger');
const Post = require('../models/Post');
const User = require('../models/User');

const router = express.Router();

// @route   GET /api/admin/dashboard
// @desc    Get admin dashboard statistics
// @access  Private (Admin only)
router.get('/dashboard', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);

    // Get current period statistics
    const totalPosts = await Post.countDocuments();
    const publishedPosts = await Post.countDocuments({ status: 'published' });
    const draftPosts = await Post.countDocuments({ status: 'draft' });
    const scheduledPosts = await Post.countDocuments({ status: 'scheduled' });

    // Get previous period statistics for comparison
    const previousPosts = await Post.countDocuments({ 
      createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } 
    });
    const currentPosts = await Post.countDocuments({ 
      createdAt: { $gte: thirtyDaysAgo } 
    });

    // Calculate post growth percentage
    const postsGrowth = previousPosts > 0 
      ? ((currentPosts - previousPosts) / previousPosts * 100).toFixed(1)
      : currentPosts > 0 ? '+100' : '0';

    // Get view statistics
    const totalViews = await Post.aggregate([
      { $group: { _id: null, totalViews: { $sum: '$analytics.views' } } }
    ]);

    const previousViews = await Post.aggregate([
      { $match: { createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } } },
      { $group: { _id: null, totalViews: { $sum: '$analytics.views' } } }
    ]);

    const currentViews = await Post.aggregate([
      { $match: { createdAt: { $gte: thirtyDaysAgo } } },
      { $group: { _id: null, totalViews: { $sum: '$analytics.views' } } }
    ]);

    const prevViewsCount = previousViews[0]?.totalViews || 0;
    const currViewsCount = currentViews[0]?.totalViews || 0;
    const viewsGrowth = prevViewsCount > 0 
      ? ((currViewsCount - prevViewsCount) / prevViewsCount * 100).toFixed(1)
      : currViewsCount > 0 ? '+100' : '0';

    // Get recent posts
    const recentPosts = await Post.find()
      .sort({ createdAt: -1 })
      .limit(5)
      .select('title status createdAt analytics.views author')
      .populate('author', 'username');

    // Get top performing posts
    const topPosts = await Post.find({ status: 'published' })
      .sort({ 'analytics.views': -1 })
      .limit(5)
      .select('title analytics.views analytics.revenue createdAt author')
      .populate('author', 'username');

    // Get automation statistics
    const autoGeneratedPosts = await Post.countDocuments({ 'automation.isAutoGenerated': true });
    const manualPosts = totalPosts - autoGeneratedPosts;

    // Get user statistics
    const totalUsers = await User.countDocuments();
    const activeUsers = await User.countDocuments({ isActive: true });

    const previousUsers = await User.countDocuments({ 
      createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } 
    });
    const currentUsers = await User.countDocuments({ 
      createdAt: { $gte: thirtyDaysAgo } 
    });

    const usersGrowth = previousUsers > 0 
      ? ((currentUsers - previousUsers) / previousUsers * 100).toFixed(1)
      : currentUsers > 0 ? '+100' : '0';

    // Calculate revenue
    const totalRevenue = await Post.aggregate([
      { $group: { _id: null, totalRevenue: { $sum: '$analytics.revenue' } } }
    ]);

    const previousRevenue = await Post.aggregate([
      { $match: { createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } } },
      { $group: { _id: null, totalRevenue: { $sum: '$analytics.revenue' } } }
    ]);

    const currentRevenue = await Post.aggregate([
      { $match: { createdAt: { $gte: thirtyDaysAgo } } },
      { $group: { _id: null, totalRevenue: { $sum: '$analytics.revenue' } } }
    ]);

    const prevRevenueCount = previousRevenue[0]?.totalRevenue || 0;
    const currRevenueCount = currentRevenue[0]?.totalRevenue || 0;
    const revenueGrowth = prevRevenueCount > 0 
      ? ((currRevenueCount - prevRevenueCount) / prevRevenueCount * 100).toFixed(1)
      : currRevenueCount > 0 ? '+100' : '0';

    res.json({
      success: true,
      data: {
        posts: {
          total: totalPosts,
          published: publishedPosts,
          draft: draftPosts,
          scheduled: scheduledPosts,
          autoGenerated: autoGeneratedPosts,
          manual: manualPosts,
          growth: postsGrowth,
          changeType: parseFloat(postsGrowth) >= 0 ? 'positive' : 'negative'
        },
        views: {
          total: totalViews[0]?.totalViews || 0,
          growth: viewsGrowth,
          changeType: parseFloat(viewsGrowth) >= 0 ? 'positive' : 'negative'
        },
        revenue: {
          total: totalRevenue[0]?.totalRevenue || 0,
          growth: revenueGrowth,
          changeType: parseFloat(revenueGrowth) >= 0 ? 'positive' : 'negative'
        },
        users: {
          total: totalUsers,
          active: activeUsers,
          growth: usersGrowth,
          changeType: parseFloat(usersGrowth) >= 0 ? 'positive' : 'negative'
        },
        recentPosts,
        topPosts,
        analytics: {
          totalContentGenerated: autoGeneratedPosts,
          automationEfficiency: totalPosts > 0 ? ((autoGeneratedPosts / totalPosts) * 100).toFixed(1) : '0',
          averageViews: totalPosts > 0 ? Math.round((totalViews[0]?.totalViews || 0) / totalPosts) : 0,
          publishedRatio: totalPosts > 0 ? ((publishedPosts / totalPosts) * 100).toFixed(1) : '0'
        }
      }
    });
  } catch (error) {
    logger.error('Dashboard error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/analytics
// @desc    Get detailed analytics data
// @access  Private (Admin only)
router.get('/analytics', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { period = '7d' } = req.query;
    
    let dateFilter = {};
    const now = new Date();
    
    switch (period) {
      case '1d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 24 * 60 * 60 * 1000) } };
        break;
      case '7d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000) } };
        break;
      case '30d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000) } };
        break;
      case '90d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000) } };
        break;
    }

    // Get posts by date
    const postsByDate = await Post.aggregate([
      { $match: dateFilter },
      {
        $group: {
          _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } },
          count: { $sum: 1 },
          views: { $sum: '$analytics.views' },
          revenue: { $sum: '$analytics.revenue' }
        }
      },
      { $sort: { _id: 1 } }
    ]);

    // Get category statistics
    const categoryStats = await Post.aggregate([
      { $match: dateFilter },
      { $unwind: '$categories' },
      {
        $group: {
          _id: '$categories',
          count: { $sum: 1 },
          views: { $sum: '$analytics.views' }
        }
      },
      { $sort: { count: -1 } }
    ]);

    // Get automation statistics
    const automationStats = await Post.aggregate([
      { $match: dateFilter },
      {
        $group: {
          _id: '$automation.isAutoGenerated',
          count: { $sum: 1 },
          avgGenerationTime: { $avg: '$automation.generationTime' },
          totalTokens: { $sum: '$automation.apiTokensUsed' }
        }
      }
    ]);

    res.json({
      success: true,
      data: {
        period,
        postsByDate,
        categoryStats,
        automationStats
      }
    });

  } catch (error) {
    logger.error('Analytics error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/settings
// @desc    Get admin settings
// @access  Private (Admin only)
router.get('/settings', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    // This would typically come from a settings collection or environment
    const settings = {
      automation: {
        enabled: process.env.AUTO_GENERATION_ENABLED === 'true',
        defaultPostsPerRun: parseInt(process.env.DEFAULT_POSTS_PER_RUN) || 1,
        maxPostsPerDay: parseInt(process.env.MAX_POSTS_PER_DAY) || 5,
        generationInterval: process.env.CONTENT_GENERATION_INTERVAL || '12h'
      },
      content: {
        defaultCategories: process.env.DEFAULT_CATEGORIES?.split(',') || ['Technology', 'AI', 'Programming'],
        defaultTags: process.env.DEFAULT_TAGS?.split(',') || ['ai', 'automation', 'blog'],
        minWordCount: parseInt(process.env.CONTENT_MIN_WORDS) || 500,
        maxWordCount: parseInt(process.env.CONTENT_MAX_WORDS) || 2000
      },
      image: {
        enabled: process.env.IMAGE_GENERATION_ENABLED === 'true',
        defaultStyle: process.env.DEFAULT_IMAGE_STYLE || 'photography',
        defaultWidth: parseInt(process.env.IMAGE_WIDTH) || 1024,
        defaultHeight: parseInt(process.env.IMAGE_HEIGHT) || 1024
      },
      monetization: {
        affiliateLinksEnabled: process.env.AFFILIATE_LINKS_ENABLED === 'true',
        adsEnabled: process.env.ADS_ENABLED === 'true'
      }
    };

    res.json({
      success: true,
      data: settings
    });

  } catch (error) {
    logger.error('Settings retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/users
// @desc    Get all users (admin only)
// @access  Private (Super Admin only)
router.get('/users', auth, authorize('super_admin'), async (req, res) => {
  try {
    const users = await User.find()
      .select('-password')
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: {
        users,
        total: users.length
      }
    });

  } catch (error) {
    logger.error('Users retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/logs
// @desc    Get system logs
// @access  Private (Admin only)
router.get('/logs', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { level = 'info', limit = 100 } = req.query;
    
    // This would typically read from log files
    // For now, return a placeholder
    const logs = [
      {
        timestamp: new Date().toISOString(),
        level: 'info',
        message: 'System logs endpoint - implement log file reading'
      }
    ];

    res.json({
      success: true,
      data: {
        logs,
        total: logs.length
      }
    });

  } catch (error) {
    logger.error('Logs retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/posts
// @desc    Get all posts for admin
// @access  Private (Admin only)
router.get('/posts', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const posts = await Post.find()
      .populate('author', 'username profile.firstName profile.lastName')
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: posts
    });
  } catch (error) {
    logger.error('Posts retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/media
// @desc    Get all media files for admin
// @access  Private (Admin only)
router.get('/media', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    // Placeholder for media files - would integrate with actual file storage
    const mediaFiles = [
      {
        _id: '1',
        filename: 'sample-image.jpg',
        originalName: 'Sample Image',
        url: '/uploads/sample-image.jpg',
        mimetype: 'image/jpeg',
        size: 1024000,
        uploadedBy: { username: 'admin' },
        uploadedAt: new Date().toISOString(),
        metadata: {
          width: 1920,
          height: 1080,
          aiPrompt: 'A beautiful landscape'
        }
      }
    ];

    res.json({
      success: true,
      data: mediaFiles
    });
  } catch (error) {
    logger.error('Media retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   POST /api/admin/generate-sample-data
// @desc    Generate sample blog posts for demonstration
// @access  Private (Admin only)
router.post('/generate-sample-data', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    // Check if sample data already exists
    const existingPosts = await Post.countDocuments();
    if (existingPosts > 0) {
      return res.status(400).json({
        success: false,
        message: 'Sample data already exists. Clear existing posts first.'
      });
    }

    const samplePosts = [
      {
        title: 'Getting Started with AI-Powered Content Creation',
        content: 'Artificial Intelligence is revolutionizing the way we create content. In this comprehensive guide, we explore the latest tools and techniques for leveraging AI in content creation...',
        excerpt: 'Discover how AI can transform your content creation process and boost productivity.',
        slug: 'getting-started-ai-content-creation',
        status: 'published',
        categories: ['AI', 'Technology', 'Content Creation'],
        tags: ['artificial intelligence', 'content', 'automation', 'productivity'],
        author: req.user.id,
        analytics: { views: Math.floor(Math.random() * 1000) + 100, revenue: Math.floor(Math.random() * 50) + 10 },
        automation: { isAutoGenerated: true, prompt: 'Write about AI content creation', generationTime: 45000, apiTokensUsed: 1200 },
        seo: { metaTitle: 'AI Content Creation Guide', metaDescription: 'Learn how to use AI for content creation', focusKeyword: 'AI content creation' },
        createdAt: new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1000)
      },
      {
        title: 'The Future of Automated Blogging',
        content: 'Automated blogging is changing the landscape of digital marketing. With advanced AI algorithms, businesses can now generate high-quality content at scale...',
        excerpt: 'Explore how automated blogging is reshaping digital marketing strategies.',
        slug: 'future-automated-blogging',
        status: 'published',
        categories: ['Blogging', 'Automation', 'Marketing'],
        tags: ['blogging', 'automation', 'digital marketing', 'AI'],
        author: req.user.id,
        analytics: { views: Math.floor(Math.random() * 800) + 200, revenue: Math.floor(Math.random() * 40) + 15 },
        automation: { isAutoGenerated: true, prompt: 'Write about automated blogging', generationTime: 52000, apiTokensUsed: 1350 },
        seo: { metaTitle: 'Future of Automated Blogging', metaDescription: 'Discover the future trends in automated blogging', focusKeyword: 'automated blogging' },
        createdAt: new Date(Date.now() - Math.floor(Math.random() * 25) * 24 * 60 * 60 * 1000)
      },
      {
        title: 'Maximizing Revenue with AI-Generated Content',
        content: 'Revenue optimization through AI-generated content is becoming increasingly sophisticated. Learn the strategies and techniques that top marketers use...',
        excerpt: 'Discover proven strategies for monetizing AI-generated content effectively.',
        slug: 'maximizing-revenue-ai-content',
        status: 'published',
        categories: ['Revenue', 'AI', 'Monetization'],
        tags: ['revenue', 'monetization', 'AI content', 'marketing'],
        author: req.user.id,
        analytics: { views: Math.floor(Math.random() * 1200) + 300, revenue: Math.floor(Math.random() * 80) + 25 },
        automation: { isAutoGenerated: true, prompt: 'Write about revenue optimization with AI content', generationTime: 48000, apiTokensUsed: 1100 },
        seo: { metaTitle: 'Maximize Revenue with AI Content', metaDescription: 'Learn to maximize revenue using AI-generated content', focusKeyword: 'AI revenue optimization' },
        createdAt: new Date(Date.now() - Math.floor(Math.random() * 20) * 24 * 60 * 60 * 1000)
      },
      {
        title: 'SEO Best Practices for AI-Generated Blog Posts',
        content: 'Search Engine Optimization for AI-generated content requires special consideration. This guide covers the essential SEO practices...',
        excerpt: 'Master SEO techniques specifically designed for AI-generated blog content.',
        slug: 'seo-best-practices-ai-posts',
        status: 'draft',
        categories: ['SEO', 'AI', 'Best Practices'],
        tags: ['SEO', 'search optimization', 'AI content', 'best practices'],
        author: req.user.id,
        analytics: { views: 0, revenue: 0 },
        automation: { isAutoGenerated: true, prompt: 'Write about SEO for AI content', generationTime: 41000, apiTokensUsed: 950 },
        seo: { metaTitle: 'SEO for AI-Generated Content', metaDescription: 'Best SEO practices for AI-generated blog posts', focusKeyword: 'AI SEO' },
        createdAt: new Date(Date.now() - Math.floor(Math.random() * 15) * 24 * 60 * 60 * 1000)
      },
      {
        title: 'Building Passive Income Streams with Automated Content',
        content: 'Creating passive income through automated content systems is the holy grail of digital entrepreneurship. This comprehensive guide shows you how...',
        excerpt: 'Learn to build sustainable passive income streams using automated content creation.',
        slug: 'building-passive-income-automated-content',
        status: 'scheduled',
        categories: ['Passive Income', 'Automation', 'Entrepreneurship'],
        tags: ['passive income', 'automation', 'entrepreneurship', 'content marketing'],
        author: req.user.id,
        analytics: { views: 0, revenue: 0 },
        automation: { isAutoGenerated: true, prompt: 'Write about passive income with automated content', generationTime: 55000, apiTokensUsed: 1400 },
        seo: { metaTitle: 'Passive Income with Automated Content', metaDescription: 'Build passive income streams using automated content creation', focusKeyword: 'passive income automation' },
        publishedAt: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),
        createdAt: new Date(Date.now() - Math.floor(Math.random() * 10) * 24 * 60 * 60 * 1000)
      }
    ];

    // Create sample posts
    const createdPosts = await Post.insertMany(samplePosts);

    logger.info(`Generated ${createdPosts.length} sample blog posts`);

    res.json({
      success: true,
      message: `Successfully generated ${createdPosts.length} sample blog posts`,
      data: {
        postsCreated: createdPosts.length,
        posts: createdPosts.map(post => ({
          id: post._id,
          title: post.title,
          status: post.status,
          views: post.analytics.views,
          revenue: post.analytics.revenue
        }))
      }
    });

  } catch (error) {
    logger.error('Sample data generation error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate sample data'
    });
  }
});

module.exports = router;

const express = require('express');
const { auth, authorize } = require('../middleware/auth');
const logger = require('../utils/logger');
const Post = require('../models/Post');
const User = require('../models/User');

const router = express.Router();

// @route   GET /api/admin/dashboard
// @desc    Get admin dashboard statistics
// @access  Private (Admin only)
router.get('/dashboard', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    // Get post statistics
    const totalPosts = await Post.countDocuments();
    const publishedPosts = await Post.countDocuments({ status: 'published' });
    const draftPosts = await Post.countDocuments({ status: 'draft' });
    const scheduledPosts = await Post.countDocuments({ status: 'scheduled' });

    // Get view statistics
    const totalViews = await Post.aggregate([
      { $group: { _id: null, totalViews: { $sum: '$analytics.views' } } }
    ]);

    // Get recent posts
    const recentPosts = await Post.find()
      .sort({ createdAt: -1 })
      .limit(5)
      .select('title status createdAt analytics.views');

    // Get top performing posts
    const topPosts = await Post.find({ status: 'published' })
      .sort({ 'analytics.views': -1 })
      .limit(5)
      .select('title analytics.views analytics.revenue createdAt');

    // Get automation statistics
    const autoGeneratedPosts = await Post.countDocuments({ 'automation.isAutoGenerated': true });
    const manualPosts = totalPosts - autoGeneratedPosts;

    // Get user statistics
    const totalUsers = await User.countDocuments();
    const activeUsers = await User.countDocuments({ isActive: true });

    // Calculate revenue (placeholder for now)
    const totalRevenue = await Post.aggregate([
      { $group: { _id: null, totalRevenue: { $sum: '$analytics.revenue' } } }
    ]);

    res.json({
      success: true,
      data: {
        posts: {
          total: totalPosts,
          published: publishedPosts,
          draft: draftPosts,
          scheduled: scheduledPosts,
          autoGenerated: autoGeneratedPosts,
          manual: manualPosts
        },
        views: {
          total: totalViews[0]?.totalViews || 0
        },
        revenue: {
          total: totalRevenue[0]?.totalRevenue || 0
        },
        users: {
          total: totalUsers,
          active: activeUsers
        },
        recentPosts,
        topPosts
      }
    });
  } catch (error) {
    logger.error('Dashboard error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/analytics
// @desc    Get detailed analytics data
// @access  Private (Admin only)
router.get('/analytics', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { period = '7d' } = req.query;
    
    let dateFilter = {};
    const now = new Date();
    
    switch (period) {
      case '1d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 24 * 60 * 60 * 1000) } };
        break;
      case '7d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000) } };
        break;
      case '30d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000) } };
        break;
      case '90d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000) } };
        break;
    }

    // Get posts by date
    const postsByDate = await Post.aggregate([
      { $match: dateFilter },
      {
        $group: {
          _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } },
          count: { $sum: 1 },
          views: { $sum: '$analytics.views' },
          revenue: { $sum: '$analytics.revenue' }
        }
      },
      { $sort: { _id: 1 } }
    ]);

    // Get category statistics
    const categoryStats = await Post.aggregate([
      { $match: dateFilter },
      { $unwind: '$categories' },
      {
        $group: {
          _id: '$categories',
          count: { $sum: 1 },
          views: { $sum: '$analytics.views' }
        }
      },
      { $sort: { count: -1 } }
    ]);

    // Get automation statistics
    const automationStats = await Post.aggregate([
      { $match: dateFilter },
      {
        $group: {
          _id: '$automation.isAutoGenerated',
          count: { $sum: 1 },
          avgGenerationTime: { $avg: '$automation.generationTime' },
          totalTokens: { $sum: '$automation.apiTokensUsed' }
        }
      }
    ]);

    res.json({
      success: true,
      data: {
        period,
        postsByDate,
        categoryStats,
        automationStats
      }
    });

  } catch (error) {
    logger.error('Analytics error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/settings
// @desc    Get admin settings
// @access  Private (Admin only)
router.get('/settings', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    // This would typically come from a settings collection or environment
    const settings = {
      automation: {
        enabled: process.env.AUTO_GENERATION_ENABLED === 'true',
        defaultPostsPerRun: parseInt(process.env.DEFAULT_POSTS_PER_RUN) || 1,
        maxPostsPerDay: parseInt(process.env.MAX_POSTS_PER_DAY) || 5,
        generationInterval: process.env.CONTENT_GENERATION_INTERVAL || '12h'
      },
      content: {
        defaultCategories: process.env.DEFAULT_CATEGORIES?.split(',') || ['Technology', 'AI', 'Programming'],
        defaultTags: process.env.DEFAULT_TAGS?.split(',') || ['ai', 'automation', 'blog'],
        minWordCount: parseInt(process.env.CONTENT_MIN_WORDS) || 500,
        maxWordCount: parseInt(process.env.CONTENT_MAX_WORDS) || 2000
      },
      image: {
        enabled: process.env.IMAGE_GENERATION_ENABLED === 'true',
        defaultStyle: process.env.DEFAULT_IMAGE_STYLE || 'photography',
        defaultWidth: parseInt(process.env.IMAGE_WIDTH) || 1024,
        defaultHeight: parseInt(process.env.IMAGE_HEIGHT) || 1024
      },
      monetization: {
        affiliateLinksEnabled: process.env.AFFILIATE_LINKS_ENABLED === 'true',
        adsEnabled: process.env.ADS_ENABLED === 'true'
      }
    };

    res.json({
      success: true,
      data: settings
    });

  } catch (error) {
    logger.error('Settings retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/users
// @desc    Get all users (admin only)
// @access  Private (Super Admin only)
router.get('/users', auth, authorize('super_admin'), async (req, res) => {
  try {
    const users = await User.find()
      .select('-password')
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: {
        users,
        total: users.length
      }
    });

  } catch (error) {
    logger.error('Users retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/logs
// @desc    Get system logs
// @access  Private (Admin only)
router.get('/logs', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { level = 'info', limit = 100 } = req.query;
    
    // This would typically read from log files
    // For now, return a placeholder
    const logs = [
      {
        timestamp: new Date().toISOString(),
        level: 'info',
        message: 'System logs endpoint - implement log file reading'
      }
    ];

    res.json({
      success: true,
      data: {
        logs,
        total: logs.length
      }
    });

  } catch (error) {
    logger.error('Logs retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

module.exports = router;

const express = require('express');
const { auth, authorize } = require('../middleware/auth');
const logger = require('../utils/logger');
const Post = require('../models/Post');
const User = require('../models/User');
const Media = require('../models/Media');
const fileUploadService = require('../services/fileUploadService');
const aiService = require('../services/aiService');
const imageService = require('../services/imageService');

const router = express.Router();

// @route   GET /api/admin/dashboard
// @desc    Get admin dashboard statistics
// @access  Private (Admin only)
router.get('/dashboard', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);

    // Get current period statistics
    const totalPosts = await Post.countDocuments();
    const publishedPosts = await Post.countDocuments({ status: 'published' });
    const draftPosts = await Post.countDocuments({ status: 'draft' });
    const scheduledPosts = await Post.countDocuments({ status: 'scheduled' });

    // Get previous period statistics for comparison
    const previousPosts = await Post.countDocuments({ 
      createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } 
    });
    const currentPosts = await Post.countDocuments({ 
      createdAt: { $gte: thirtyDaysAgo } 
    });

    // Calculate post growth percentage
    const postsGrowth = previousPosts > 0 
      ? ((currentPosts - previousPosts) / previousPosts * 100).toFixed(1)
      : currentPosts > 0 ? '+100' : '0';

    // Get view statistics
    const totalViews = await Post.aggregate([
      { $group: { _id: null, totalViews: { $sum: '$analytics.views' } } }
    ]);

    const previousViews = await Post.aggregate([
      { $match: { createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } } },
      { $group: { _id: null, totalViews: { $sum: '$analytics.views' } } }
    ]);

    const currentViews = await Post.aggregate([
      { $match: { createdAt: { $gte: thirtyDaysAgo } } },
      { $group: { _id: null, totalViews: { $sum: '$analytics.views' } } }
    ]);

    const prevViewsCount = previousViews[0]?.totalViews || 0;
    const currViewsCount = currentViews[0]?.totalViews || 0;
    const viewsGrowth = prevViewsCount > 0 
      ? ((currViewsCount - prevViewsCount) / prevViewsCount * 100).toFixed(1)
      : currViewsCount > 0 ? '+100' : '0';

    // Get recent posts
    const recentPosts = await Post.find()
      .sort({ createdAt: -1 })
      .limit(5)
      .select('title status createdAt analytics.views author')
      .populate('author', 'username');

    // Get top performing posts
    const topPosts = await Post.find({ status: 'published' })
      .sort({ 'analytics.views': -1 })
      .limit(5)
      .select('title analytics.views analytics.revenue createdAt author')
      .populate('author', 'username');

    // Get automation statistics
    const autoGeneratedPosts = await Post.countDocuments({ 'automation.isAutoGenerated': true });
    const manualPosts = totalPosts - autoGeneratedPosts;

    // Get user statistics
    const totalUsers = await User.countDocuments();
    const activeUsers = await User.countDocuments({ isActive: true });

    const previousUsers = await User.countDocuments({ 
      createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } 
    });
    const currentUsers = await User.countDocuments({ 
      createdAt: { $gte: thirtyDaysAgo } 
    });

    const usersGrowth = previousUsers > 0 
      ? ((currentUsers - previousUsers) / previousUsers * 100).toFixed(1)
      : currentUsers > 0 ? '+100' : '0';

    // Calculate revenue
    const totalRevenue = await Post.aggregate([
      { $group: { _id: null, totalRevenue: { $sum: '$analytics.revenue' } } }
    ]);

    const previousRevenue = await Post.aggregate([
      { $match: { createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo } } },
      { $group: { _id: null, totalRevenue: { $sum: '$analytics.revenue' } } }
    ]);

    const currentRevenue = await Post.aggregate([
      { $match: { createdAt: { $gte: thirtyDaysAgo } } },
      { $group: { _id: null, totalRevenue: { $sum: '$analytics.revenue' } } }
    ]);

    const prevRevenueCount = previousRevenue[0]?.totalRevenue || 0;
    const currRevenueCount = currentRevenue[0]?.totalRevenue || 0;
    const revenueGrowth = prevRevenueCount > 0 
      ? ((currRevenueCount - prevRevenueCount) / prevRevenueCount * 100).toFixed(1)
      : currRevenueCount > 0 ? '+100' : '0';

    res.json({
      success: true,
      data: {
        posts: {
          total: totalPosts,
          published: publishedPosts,
          draft: draftPosts,
          scheduled: scheduledPosts,
          autoGenerated: autoGeneratedPosts,
          manual: manualPosts,
          growth: postsGrowth,
          changeType: parseFloat(postsGrowth) >= 0 ? 'positive' : 'negative'
        },
        views: {
          total: totalViews[0]?.totalViews || 0,
          growth: viewsGrowth,
          changeType: parseFloat(viewsGrowth) >= 0 ? 'positive' : 'negative'
        },
        revenue: {
          total: totalRevenue[0]?.totalRevenue || 0,
          growth: revenueGrowth,
          changeType: parseFloat(revenueGrowth) >= 0 ? 'positive' : 'negative'
        },
        users: {
          total: totalUsers,
          active: activeUsers,
          growth: usersGrowth,
          changeType: parseFloat(usersGrowth) >= 0 ? 'positive' : 'negative'
        },
        recentPosts,
        topPosts,
        analytics: {
          totalContentGenerated: autoGeneratedPosts,
          automationEfficiency: totalPosts > 0 ? ((autoGeneratedPosts / totalPosts) * 100).toFixed(1) : '0',
          averageViews: totalPosts > 0 ? Math.round((totalViews[0]?.totalViews || 0) / totalPosts) : 0,
          publishedRatio: totalPosts > 0 ? ((publishedPosts / totalPosts) * 100).toFixed(1) : '0'
        }
      }
    });
  } catch (error) {
    logger.error('Dashboard error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/analytics
// @desc    Get detailed analytics data
// @access  Private (Admin only)
router.get('/analytics', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { period = '7d', type = 'overview' } = req.query;
    
    let dateFilter = {};
    const now = new Date();
    let groupByFormat = '%Y-%m-%d'; // Default daily grouping
    
    switch (period) {
      case '1d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 24 * 60 * 60 * 1000) } };
        groupByFormat = '%Y-%m-%d %H:00'; // Hourly grouping for 1 day
        break;
      case '7d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000) } };
        break;
      case '30d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000) } };
        break;
      case '90d':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000) } };
        groupByFormat = '%Y-%U'; // Weekly grouping for 90 days
        break;
      case '1y':
        dateFilter = { createdAt: { $gte: new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000) } };
        groupByFormat = '%Y-%m'; // Monthly grouping for 1 year
        break;
    }

    const analyticsData = {};

    if (type === 'overview' || type === 'posts') {
      // Posts analytics over time
      const postsByDate = await Post.aggregate([
        { $match: dateFilter },
        {
          $group: {
            _id: { $dateToString: { format: groupByFormat, date: '$createdAt' } },
            count: { $sum: 1 },
            views: { $sum: '$analytics.views' },
            revenue: { $sum: '$analytics.revenue' },
            published: { $sum: { $cond: [{ $eq: ['$status', 'published'] }, 1, 0] } },
            drafts: { $sum: { $cond: [{ $eq: ['$status', 'draft'] }, 1, 0] } },
            aiGenerated: { $sum: { $cond: ['$automation.isAutoGenerated', 1, 0] } }
          }
        },
        { $sort: { _id: 1 } }
      ]);

      analyticsData.postsByDate = postsByDate;
    }

    if (type === 'overview' || type === 'performance') {
      // Top performing posts
      const topPosts = await Post.find(dateFilter)
        .sort({ 'analytics.views': -1 })
        .limit(10)
        .select('title slug analytics status createdAt categories')
        .populate('author', 'username');

      // Performance metrics
      const performanceMetrics = await Post.aggregate([
        { $match: { ...dateFilter, status: 'published' } },
        {
          $group: {
            _id: null,
            avgViews: { $avg: '$analytics.views' },
            avgRevenue: { $avg: '$analytics.revenue' },
            totalViews: { $sum: '$analytics.views' },
            totalRevenue: { $sum: '$analytics.revenue' },
            avgEngagement: { $avg: { $add: ['$analytics.engagement.likes', '$analytics.engagement.comments', '$analytics.engagement.shares'] } },
            totalEngagement: { $sum: { $add: ['$analytics.engagement.likes', '$analytics.engagement.comments', '$analytics.engagement.shares'] } }
          }
        }
      ]);

      analyticsData.topPosts = topPosts;
      analyticsData.performanceMetrics = performanceMetrics[0] || {
        avgViews: 0, avgRevenue: 0, totalViews: 0, totalRevenue: 0,
        avgEngagement: 0, totalEngagement: 0
      };
    }

    if (type === 'overview' || type === 'categories') {
      // Category performance
      const categoryStats = await Post.aggregate([
        { $match: dateFilter },
        { $unwind: '$categories' },
        {
          $group: {
            _id: '$categories',
            count: { $sum: 1 },
            views: { $sum: '$analytics.views' },
            revenue: { $sum: '$analytics.revenue' },
            avgViews: { $avg: '$analytics.views' },
            publishedCount: { $sum: { $cond: [{ $eq: ['$status', 'published'] }, 1, 0] } }
          }
        },
        { $sort: { views: -1 } }
      ]);

      analyticsData.categoryStats = categoryStats;
    }

    if (type === 'overview' || type === 'automation') {
      // Automation statistics
      const automationStats = await Post.aggregate([
        { $match: dateFilter },
        {
          $group: {
            _id: '$automation.isAutoGenerated',
            count: { $sum: 1 },
            avgGenerationTime: { $avg: '$automation.generationTime' },
            totalTokens: { $sum: '$automation.apiTokensUsed' },
            avgTokens: { $avg: '$automation.apiTokensUsed' },
            totalViews: { $sum: '$analytics.views' },
            totalRevenue: { $sum: '$analytics.revenue' }
          }
        }
      ]);

      // AI efficiency metrics
      const aiEfficiency = await Post.aggregate([
        { $match: { ...dateFilter, 'automation.isAutoGenerated': true } },
        {
          $group: {
            _id: null,
            avgTimePerPost: { $avg: '$automation.generationTime' },
            avgTokensPerPost: { $avg: '$automation.apiTokensUsed' },
            avgViewsPerAIPost: { $avg: '$analytics.views' },
            avgRevenuePerAIPost: { $avg: '$analytics.revenue' },
            totalAIPosts: { $sum: 1 }
          }
        }
      ]);

      // Image source statistics
      const imageSourceStats = await Post.aggregate([
        { $match: dateFilter },
        {
          $group: {
            _id: '$automation.imageSource',
            count: { $sum: 1 }
          }
        }
      ]);

      analyticsData.automationStats = automationStats;
      analyticsData.aiEfficiency = aiEfficiency[0] || {};
      analyticsData.imageSourceStats = imageSourceStats;
    }

    if (type === 'overview' || type === 'users') {
      // User activity statistics
      const userStats = await User.aggregate([
        { $match: { createdAt: dateFilter.createdAt || { $exists: true } } },
        {
          $group: {
            _id: null,
            totalUsers: { $sum: 1 },
            activeUsers: { $sum: { $cond: ['$isActive', 1, 0] } },
            adminUsers: { $sum: { $cond: [{ $in: ['$role', ['admin', 'super_admin']] }, 1, 0] } }
          }
        }
      ]);

      // Posts per user
      const postsPerUser = await Post.aggregate([
        { $match: dateFilter },
        {
          $group: {
            _id: '$author',
            postCount: { $sum: 1 },
            totalViews: { $sum: '$analytics.views' },
            totalRevenue: { $sum: '$analytics.revenue' }
          }
        },
        {
          $lookup: {
            from: 'users',
            localField: '_id',
            foreignField: '_id',
            as: 'user'
          }
        },
        { $unwind: '$user' },
        {
          $project: {
            username: '$user.username',
            postCount: 1,
            totalViews: 1,
            totalRevenue: 1,
            avgViewsPerPost: { $divide: ['$totalViews', '$postCount'] }
          }
        },
        { $sort: { postCount: -1 } },
        { $limit: 10 }
      ]);

      analyticsData.userStats = userStats[0] || { totalUsers: 0, activeUsers: 0, adminUsers: 0 };
      analyticsData.postsPerUser = postsPerUser;
    }

    if (type === 'overview' || type === 'media') {
      // Media statistics
      const mediaStats = await Media.aggregate([
        { $match: { uploadedAt: dateFilter.createdAt || { $exists: true } } },
        {
          $group: {
            _id: '$category',
            count: { $sum: 1 },
            totalSize: { $sum: '$size' },
            avgSize: { $avg: '$size' },
            totalUsage: { $sum: '$usageCount' }
          }
        }
      ]);

      const totalMediaStats = await Media.aggregate([
        { $match: { uploadedAt: dateFilter.createdAt || { $exists: true } } },
        {
          $group: {
            _id: null,
            totalFiles: { $sum: 1 },
            totalSize: { $sum: '$size' },
            avgUsage: { $avg: '$usageCount' },
            totalUsage: { $sum: '$usageCount' }
          }
        }
      ]);

      analyticsData.mediaStats = {
        byCategory: mediaStats,
        total: totalMediaStats[0] || { totalFiles: 0, totalSize: 0, avgUsage: 0, totalUsage: 0 }
      };
    }

    // Calculate growth rates for overview
    if (type === 'overview') {
      const previousPeriodFilter = {};
      const periodMs = {
        '1d': 24 * 60 * 60 * 1000,
        '7d': 7 * 24 * 60 * 60 * 1000,
        '30d': 30 * 24 * 60 * 60 * 1000,
        '90d': 90 * 24 * 60 * 60 * 1000,
        '1y': 365 * 24 * 60 * 60 * 1000
      };

      const currentPeriodMs = periodMs[period] || periodMs['7d'];
      previousPeriodFilter.createdAt = {
        $gte: new Date(now.getTime() - 2 * currentPeriodMs),
        $lt: new Date(now.getTime() - currentPeriodMs)
      };

      const previousPeriodStats = await Post.aggregate([
        { $match: previousPeriodFilter },
        {
          $group: {
            _id: null,
            count: { $sum: 1 },
            views: { $sum: '$analytics.views' },
            revenue: { $sum: '$analytics.revenue' }
          }
        }
      ]);

      const currentPeriodStats = await Post.aggregate([
        { $match: dateFilter },
        {
          $group: {
            _id: null,
            count: { $sum: 1 },
            views: { $sum: '$analytics.views' },
            revenue: { $sum: '$analytics.revenue' }
          }
        }
      ]);

      const prev = previousPeriodStats[0] || { count: 0, views: 0, revenue: 0 };
      const curr = currentPeriodStats[0] || { count: 0, views: 0, revenue: 0 };

      analyticsData.growthRates = {
        posts: prev.count > 0 ? ((curr.count - prev.count) / prev.count * 100).toFixed(1) : (curr.count > 0 ? '+100' : '0'),
        views: prev.views > 0 ? ((curr.views - prev.views) / prev.views * 100).toFixed(1) : (curr.views > 0 ? '+100' : '0'),
        revenue: prev.revenue > 0 ? ((curr.revenue - prev.revenue) / prev.revenue * 100).toFixed(1) : (curr.revenue > 0 ? '+100' : '0')
      };
    }

    res.json({
      success: true,
      data: {
        period,
        type,
        generatedAt: new Date().toISOString(),
        ...analyticsData
      }
    });

  } catch (error) {
    logger.error('Analytics error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/settings
// @desc    Get admin settings
// @access  Private (Admin only)
router.get('/settings', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    // This would typically come from a settings collection or environment
    const settings = {
      automation: {
        enabled: process.env.AUTO_GENERATION_ENABLED === 'true',
        defaultPostsPerRun: parseInt(process.env.DEFAULT_POSTS_PER_RUN) || 1,
        maxPostsPerDay: parseInt(process.env.MAX_POSTS_PER_DAY) || 5,
        generationInterval: process.env.CONTENT_GENERATION_INTERVAL || '12h'
      },
      content: {
        defaultCategories: process.env.DEFAULT_CATEGORIES?.split(',') || ['Technology', 'AI', 'Programming'],
        defaultTags: process.env.DEFAULT_TAGS?.split(',') || ['ai', 'automation', 'blog'],
        minWordCount: parseInt(process.env.CONTENT_MIN_WORDS) || 500,
        maxWordCount: parseInt(process.env.CONTENT_MAX_WORDS) || 2000
      },
      image: {
        enabled: process.env.IMAGE_GENERATION_ENABLED === 'true',
        defaultStyle: process.env.DEFAULT_IMAGE_STYLE || 'photography',
        defaultWidth: parseInt(process.env.IMAGE_WIDTH) || 1024,
        defaultHeight: parseInt(process.env.IMAGE_HEIGHT) || 1024
      },
      monetization: {
        affiliateLinksEnabled: process.env.AFFILIATE_LINKS_ENABLED === 'true',
        adsEnabled: process.env.ADS_ENABLED === 'true'
      }
    };

    res.json({
      success: true,
      data: settings
    });

  } catch (error) {
    logger.error('Settings retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/users
// @desc    Get all users (admin only)
// @access  Private (Super Admin only)
router.get('/users', auth, authorize('super_admin'), async (req, res) => {
  try {
    const users = await User.find()
      .select('-password')
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: {
        users,
        total: users.length
      }
    });

  } catch (error) {
    logger.error('Users retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/logs
// @desc    Get system logs
// @access  Private (Admin only)
router.get('/logs', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { level = 'info', limit = 100 } = req.query;
    
    // This would typically read from log files
    // For now, return a placeholder
    const logs = [
      {
        timestamp: new Date().toISOString(),
        level: 'info',
        message: 'System logs endpoint - implement log file reading'
      }
    ];

    res.json({
      success: true,
      data: {
        logs,
        total: logs.length
      }
    });

  } catch (error) {
    logger.error('Logs retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/posts
// @desc    Get all posts for admin
// @access  Private (Admin only)
router.get('/posts', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const posts = await Post.find()
      .populate('author', 'username profile.firstName profile.lastName')
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: posts
    });
  } catch (error) {
    logger.error('Posts retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   GET /api/admin/media
// @desc    Get all media files for admin
// @access  Private (Admin only)
router.get('/media', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 20, 
      category, 
      search, 
      sortBy = 'uploadedAt', 
      sortOrder = 'desc' 
    } = req.query;

    // Build query
    let query = { isActive: true };
    
    if (category && category !== 'all') {
      query.category = category;
    }
    
    if (search) {
      query.$text = { $search: search };
    }

    // Build sort object
    const sort = {};
    sort[sortBy] = sortOrder === 'asc' ? 1 : -1;

    // Get paginated results
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    const [mediaFiles, totalCount, storageStats] = await Promise.all([
      Media.find(query)
        .populate('uploadedBy', 'username profile.firstName profile.lastName')
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit)),
      Media.countDocuments(query),
      fileUploadService.getStorageStats()
    ]);

    res.json({
      success: true,
      data: {
        mediaFiles,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalCount / parseInt(limit)),
          totalItems: totalCount,
          itemsPerPage: parseInt(limit)
        },
        storageStats
      }
    });
  } catch (error) {
    logger.error('Media retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// @route   POST /api/admin/media/upload
// @desc    Upload media files
// @access  Private (Admin only)
router.post('/media/upload', auth, authorize('admin', 'super_admin'), (req, res) => {
  fileUploadService.getUploadMiddleware()(req, res, async (err) => {
    if (err) {
      logger.error('File upload error:', err);
      return res.status(400).json({
        success: false,
        message: err.message
      });
    }

    try {
      if (!req.files || req.files.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'No files uploaded'
        });
      }

      const uploadedFiles = await fileUploadService.processUploadedFiles(req.files, req.user.id);

      res.json({
        success: true,
        message: `Successfully uploaded ${uploadedFiles.length} file(s)`,
        data: uploadedFiles
      });

    } catch (error) {
      logger.error('File processing error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to process uploaded files'
      });
    }
  });
});

// @route   DELETE /api/admin/media/:id
// @desc    Delete media file
// @access  Private (Admin only)
router.delete('/media/:id', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    await fileUploadService.deleteFile(req.params.id, req.user.id);
    
    res.json({
      success: true,
      message: 'File deleted successfully'
    });
  } catch (error) {
    logger.error('File deletion error:', error);
    res.status(400).json({
      success: false,
      message: error.message
    });
  }
});

// @route   POST /api/admin/media/ai-generate
// @desc    Generate media using AI
// @access  Private (Admin only)
router.post('/media/ai-generate', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { prompt, style = 'photography', width = 1024, height = 1024 } = req.body;

    if (!prompt) {
      return res.status(400).json({
        success: false,
        message: 'Prompt is required'
      });
    }

    // Generate image using AI service
    const imageResult = await imageService.getBlogImage(prompt, {
      style,
      aspectRatio: `${width}:${height}`
    });

    if (!imageResult.success) {
      throw new Error(imageResult.error || 'Image generation failed');
    }

    // Create media record
    const mediaData = {
      filename: `ai-generated-${Date.now()}.jpg`,
      originalName: `AI Generated: ${prompt.substring(0, 50)}...`,
      url: imageResult.imageUrl,
      mimetype: 'image/jpeg',
      size: 0, // Will be updated when we know the actual size
      uploadedBy: req.user.id,
      category: 'image',
      metadata: {
        source: imageResult.source || 'ai_generated',
        aiPrompt: prompt,
        width: width,
        height: height,
        // Add Unsplash specific data if from stock images
        ...(imageResult.unsplashData && {
          unsplashId: imageResult.unsplashData.id,
          photographer: imageResult.unsplashData.photographer,
          photographerUrl: imageResult.unsplashData.photographerUrl,
          attribution: imageResult.unsplashData.attribution
        })
      },
      tags: prompt.split(' ').filter(word => word.length > 2).slice(0, 5)
    };

    const media = new Media(mediaData);
    await media.save();

    logger.info(`AI image generated: ${prompt} by user ${req.user.id}`);

    res.json({
      success: true,
      message: 'Image generated successfully',
      data: media
    });

  } catch (error) {
    logger.error('AI image generation error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// @route   POST /api/admin/generate-content
// @desc    Generate AI-powered blog posts
// @access  Private (Admin only)
router.post('/generate-content', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { 
      count = 5, 
      topics = [], 
      categories = ['AI', 'Technology', 'Automation'], 
      generateImages = true,
      publishImmediately = false 
    } = req.body;

    if (count > 10) {
      return res.status(400).json({
        success: false,
        message: 'Maximum 10 posts can be generated at once'
      });
    }

    const generatedPosts = [];
    const errors = [];

    // Default topics if none provided
    const defaultTopics = [
      'AI-powered content creation strategies',
      'The future of automated blogging platforms',
      'Maximizing revenue with AI-generated content',
      'SEO optimization for AI-generated blog posts',
      'Building passive income with automated content systems',
      'Machine learning in content marketing',
      'Ethical considerations in AI content generation',
      'The impact of AI on digital marketing',
      'Automation tools for content creators',
      'Advanced AI techniques for blog monetization'
    ];

    const topicsToUse = topics.length > 0 ? topics : defaultTopics.slice(0, count);

    for (let i = 0; i < Math.min(count, topicsToUse.length); i++) {
      try {
        const topic = topicsToUse[i];
        const startTime = Date.now();

        // Generate content using AI service
        if (!aiService.isEnabled()) {
          throw new Error('AI service is not enabled. Please configure GEMINI_API_KEY.');
        }

        const contentResult = await aiService.generateBlogPost({
          topic,
          categories: categories,
          wordCount: Math.floor(Math.random() * 1000) + 800, // 800-1800 words
          includeImages: generateImages
        });

        if (!contentResult.success) {
          throw new Error(contentResult.error || 'Content generation failed');
        }

        const generationTime = Date.now() - startTime;

        // Generate featured image if requested
        let featuredImage = null;
        if (generateImages) {
          try {
            const imageResult = await imageService.getBlogImage(contentResult.title, {
              style: 'photography',
              aspectRatio: '16:9'
            });

            if (imageResult.success) {
              featuredImage = {
                url: imageResult.imageUrl,
                alt: contentResult.title,
                source: imageResult.source || 'ai_generated',
                ...(imageResult.unsplashData && {
                  photographer: imageResult.unsplashData.photographer,
                  photographerUrl: imageResult.unsplashData.photographerUrl,
                  attribution: imageResult.unsplashData.attribution,
                  unsplashId: imageResult.unsplashData.id
                }),
                ...(imageResult.aiPrompt && {
                  aiPrompt: imageResult.aiPrompt
                })
              };
            }
          } catch (imageError) {
            logger.warn(`Image generation failed for post "${contentResult.title}":`, imageError.message);
          }
        }

        // Create post
        const postData = {
          title: contentResult.title,
          content: contentResult.content,
          excerpt: contentResult.excerpt,
          slug: contentResult.slug,
          status: publishImmediately ? 'published' : 'draft',
          categories: contentResult.categories || categories,
          tags: contentResult.tags || [],
          author: req.user.id,
          featuredImage,
          seo: {
            metaTitle: contentResult.seoTitle || contentResult.title,
            metaDescription: contentResult.metaDescription || contentResult.excerpt,
            focusKeyword: contentResult.focusKeyword || topic.split(' ')[0]
          },
          automation: {
            isAutoGenerated: true,
            generationDate: new Date(),
            aiPrompt: topic,
            generationTime,
            apiTokensUsed: contentResult.tokensUsed || 0,
            imageSource: featuredImage ? featuredImage.source : 'none'
          },
          analytics: {
            views: 0,
            revenue: 0,
            engagement: {
              likes: 0,
              comments: 0,
              shares: 0
            }
          }
        };

        if (publishImmediately) {
          postData.publishedAt = new Date();
        }

        const post = new Post(postData);
        await post.save();

        generatedPosts.push({
          id: post._id,
          title: post.title,
          status: post.status,
          slug: post.slug,
          generationTime,
          tokensUsed: contentResult.tokensUsed || 0,
          hasImage: !!featuredImage
        });

        logger.info(`AI-generated post created: "${post.title}" by user ${req.user.id}`);

      } catch (error) {
        logger.error(`Error generating post ${i + 1}:`, error);
        errors.push({
          index: i + 1,
          topic: topicsToUse[i],
          error: error.message
        });
      }
    }

    res.json({
      success: true,
      message: `Generated ${generatedPosts.length} blog post(s)`,
      data: {
        postsGenerated: generatedPosts.length,
        posts: generatedPosts,
        errors: errors.length > 0 ? errors : undefined
      }
    });

  } catch (error) {
    logger.error('Content generation error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// @route   POST /api/admin/bulk-operations
// @desc    Perform bulk operations on posts
// @access  Private (Admin only)
router.post('/bulk-operations', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const { operation, postIds, data } = req.body;

    if (!operation || !postIds || !Array.isArray(postIds)) {
      return res.status(400).json({
        success: false,
        message: 'Operation and postIds array are required'
      });
    }

    let result;
    
    switch (operation) {
      case 'publish':
        result = await Post.updateMany(
          { _id: { $in: postIds }, status: { $ne: 'published' } },
          { 
            status: 'published', 
            publishedAt: new Date() 
          }
        );
        break;
        
      case 'unpublish':
        result = await Post.updateMany(
          { _id: { $in: postIds } },
          { 
            status: 'draft',
            $unset: { publishedAt: 1 }
          }
        );
        break;
        
      case 'delete':
        result = await Post.deleteMany({ _id: { $in: postIds } });
        break;
        
      case 'updateCategory':
        if (!data.categories) {
          return res.status(400).json({
            success: false,
            message: 'Categories are required for updateCategory operation'
          });
        }
        result = await Post.updateMany(
          { _id: { $in: postIds } },
          { categories: data.categories }
        );
        break;
        
      default:
        return res.status(400).json({
          success: false,
          message: 'Invalid operation'
        });
    }

    logger.info(`Bulk operation "${operation}" performed on ${postIds.length} posts by user ${req.user.id}`);

    res.json({
      success: true,
      message: `Bulk ${operation} completed`,
      data: {
        operation,
        postsAffected: result.modifiedCount || result.deletedCount || 0,
        totalRequested: postIds.length
      }
    });

  } catch (error) {
    logger.error('Bulk operation error:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

module.exports = router;

const express = require('express');
const { body, validationResult } = require('express-validator');
const { auth, authorize } = require('../middleware/auth');
const logger = require('../utils/logger');
const aiService = require('../services/aiService');
const imageService = require('../services/imageService');
const Post = require('../models/Post');

const router = express.Router();

// @route   POST /api/automation/generate
// @desc    Manually trigger content generation
// @access  Private (Admin only)
router.post('/generate', [
  auth, 
  authorize('admin', 'super_admin'),
  body('topic').notEmpty().withMessage('Topic is required'),
  body('category').optional().isString(),
  body('keywords').optional().isArray(),
  body('style').optional().isIn(['informative', 'conversational', 'professional']),
  body('wordCount').optional().isInt({ min: 300, max: 3000 }),
  body('generateImage').optional().isBoolean(),
  body('imageStyle').optional().isIn(['photography', 'digital-art', 'cartoon', 'minimalist', 'vintage', 'modern'])
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    const {
      topic,
      category = 'general',
      keywords = [],
      style = 'informative',
      wordCount = 800,
      generateImage = true,
      imageStyle = 'photography'
    } = req.body;

    logger.info(`Starting content generation for topic: ${topic}`);

    // Generate blog post content
    const contentResult = await aiService.generateBlogPost(topic, {
      style,
      seoKeywords: keywords,
      targetWordCount: wordCount
    });

    // Generate image if requested
    let imageResult = null;
    if (generateImage) {
      try {
        const imagePrompt = await aiService.generateImagePrompt(contentResult.content, imageStyle);
        imageResult = await imageService.getBlogImage(contentResult.content, {
          style: imageStyle,
          aspectRatio: '16:9'
        });
      } catch (imageError) {
        logger.warn('Image generation failed, continuing without image:', imageError.message);
      }
    }

    // Create post object
    const postData = {
      title: topic,
      content: contentResult.content,
      category: category,
      tags: keywords,
      author: req.user.id,
      status: 'draft',
      automation: {
        isAutoGenerated: true,
        generationDate: new Date(),
        aiPrompt: contentResult.metadata.prompt,
        generationTime: contentResult.metadata.generationTime,
        apiTokensUsed: contentResult.metadata.estimatedTokens
      }
    };

    // Add image data if generated
    if (imageResult && imageResult.success) {
      if (imageResult.type === 'stock') {
        // Stock image from Unsplash
        postData.featuredImage = {
          url: imageResult.image.urls.regular,
          alt: imageResult.image.description || `Stock image for ${topic}`,
          source: 'unsplash',
          photographer: imageResult.image.photographer.name,
          photographerUrl: imageResult.image.photographer.profileUrl,
          attribution: imageResult.attribution,
          unsplashId: imageResult.image.id
        };
        
        postData.automation.imageSource = 'stock';
        postData.automation.imageQuery = imageResult.metadata.query;
      } else if (imageResult.type === 'ai_generated') {
        // AI-generated image
        const filename = imageService.generateFilename('blog');
        const saveResult = await imageService.saveImage(imageResult.imageData, filename);
        
        postData.featuredImage = {
          url: `/uploads/${filename}`,
          alt: `AI-generated image for ${topic}`,
          source: 'ai_generated',
          aiPrompt: imageResult.metadata.prompt
        };
        
        postData.automation.imageSource = 'ai_generated';
        postData.automation.imageGenerationTime = imageResult.metadata.generationTime;
      }
    }

    // Save post to database
    const post = new Post(postData);
    await post.save();

    logger.info(`Content generation completed successfully. Post ID: ${post._id}`);

    res.json({
      success: true,
      message: 'Content generated successfully',
      data: {
        post: {
          id: post._id,
          title: post.title,
          slug: post.slug,
          status: post.status,
          wordCount: post.wordCount,
          readingTime: post.readingTime
        },
        generation: {
          contentTime: contentResult.metadata.generationTime,
          imageTime: imageResult?.metadata?.generationTime || 0,
          totalTokens: contentResult.metadata.estimatedTokens,
          imageGenerated: !!imageResult?.success
        }
      }
    });

  } catch (error) {
    logger.error('Content generation error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to generate content'
    });
  }
});

// @route   POST /api/automation/generate-ideas
// @desc    Generate content ideas for a category
// @access  Private (Admin only)
router.post('/generate-ideas', [
  auth, 
  authorize('admin', 'super_admin'),
  body('category').notEmpty().withMessage('Category is required'),
  body('count').optional().isInt({ min: 1, max: 10 })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    const { category, count = 5 } = req.body;

    const ideas = await aiService.generateContentIdeas(category, count);

    res.json({
      success: true,
      message: 'Content ideas generated successfully',
      data: {
        ideas,
        category,
        count: ideas.length
      }
    });

  } catch (error) {
    logger.error('Content ideas generation error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to generate content ideas'
    });
  }
});

// @route   POST /api/automation/generate-image
// @desc    Generate image for existing content
// @access  Private (Admin only)
router.post('/generate-image', [
  auth, 
  authorize('admin', 'super_admin'),
  body('content').notEmpty().withMessage('Content is required'),
  body('style').optional().isIn(['photography', 'digital-art', 'cartoon', 'minimalist', 'vintage', 'modern']),
  body('aspectRatio').optional().isIn(['1:1', '16:9', '4:3', '3:2', '9:16'])
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    const { content, style = 'photography', aspectRatio = '16:9' } = req.body;

    const imageResult = await imageService.getBlogImage(content, {
      style,
      aspectRatio
    });

    if (imageResult.success) {
      if (imageResult.type === 'stock') {
        // Stock image from Unsplash
        res.json({
          success: true,
          message: 'Stock image found successfully',
          data: {
            imageUrl: imageResult.image.urls.regular,
            source: 'unsplash',
            photographer: imageResult.image.photographer.name,
            photographerUrl: imageResult.image.photographer.profileUrl,
            attribution: imageResult.attribution,
            metadata: imageResult.metadata
          }
        });
      } else if (imageResult.type === 'ai_generated') {
        // AI-generated image
        const filename = imageService.generateFilename('blog');
        const saveResult = await imageService.saveImage(imageResult.imageData, filename);
        
        res.json({
          success: true,
          message: 'AI image generated successfully',
          data: {
            imageUrl: `/uploads/${filename}`,
            filename,
            source: 'ai_generated',
            metadata: imageResult.metadata
          }
        });
      }
    } else {
      throw new Error('Image generation failed');
    }

  } catch (error) {
    logger.error('Image generation error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to generate image'
    });
  }
});

// @route   GET /api/automation/status
// @desc    Get automation service status
// @access  Private (Admin only)
router.get('/status', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const aiStatus = await aiService.testConnection();
    const imageStatus = await imageService.testConnection();

    res.json({
      success: true,
      data: {
        ai: {
          enabled: aiStatus.success,
          message: aiStatus.message || aiStatus.error
        },
        image: {
          enabled: imageStatus.success,
          message: imageStatus.message || imageStatus.error
        },
        services: {
          ai: !!process.env.GEMINI_API_KEY,
          image: !!process.env.STABLE_DIFFUSION_API_KEY
        }
      }
    });

  } catch (error) {
    logger.error('Status check error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to check service status'
    });
  }
});

// @route   GET /api/automation/stats
// @desc    Get automation usage statistics
// @access  Private (Admin only)
router.get('/stats', auth, authorize('admin', 'super_admin'), async (req, res) => {
  try {
    const aiStats = aiService.getUsageStats();
    const imageStats = imageService.getUsageStats();

    // Get database stats
    const totalPosts = await Post.countDocuments();
    const autoGeneratedPosts = await Post.countDocuments({ 'automation.isAutoGenerated': true });
    const recentPosts = await Post.countDocuments({
      createdAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
    });

    res.json({
      success: true,
      data: {
        posts: {
          total: totalPosts,
          autoGenerated: autoGeneratedPosts,
          recent: recentPosts
        },
        ai: aiStats,
        image: imageStats
      }
    });

  } catch (error) {
    logger.error('Stats retrieval error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to retrieve statistics'
    });
  }
});

module.exports = router;
